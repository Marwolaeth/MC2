# Notation & computing {#sec-notation-and-computing}

```{r child="../starter.Rmd"}
```


> *The ideas which are here expressed so laboriously are extremely simple .... The difficulty lies, not in the new ideas, but in escaping from the old ones, which [branch]^[Original word: "ramify"], for those brought up as most of us have been, into every corner of our minds.* --- J. M Keynes, 1936, [*The General Theory of Employment, Interest, and Money*](files.ethz.ch/isn/125515/1366_KeynesTheoryofEmployment.pdf), 1936

This chapter introduces more of the notation we will use for mathematics and for computing. 

::: {.column-margin}
**Notation** (noun): a series or system of written symbols used to represent numbers, amounts, or elements in something such as music or mathematics. --Oxford Dictionaries 
:::

Good use of notation should make *meaning* clear to a human reader. In our study of calculus, each component of notation will refer to a mathematical object of some kind. An elemental part of discerning meaning is to recognize the *kind of object*. In the previous chapter, we described three different kinds of objects: functions, quantities, and spaces. We introduced mathematical and computer notation to make clear what is the name of a function and the names of inputs.  In this chapter, we'll introduce ***constants***, ***parameters***, and ***special inputs***. We'll see how input names, like $x$ in $g(x) \equiv x^3 + 3$ refer to a kind of space called a ***domain***. 

It makes obvious sense to use a mathematical notation with which you are already familiar. We'll supplement this notation with simple rules for naming, intended to make it clear just from the name what kind of mathematical object is being named.  

We also need to highlight the ways in which high-school math notation is incompatible or misleading when it comes to computing: 

1. Traditional mathematical notation makes extensive use of spatial arrangement, as for instance in $\frac{3}{4}$ or $x^{-3}$ or $\sqrt[4]{\strut y^2 - 6}$. For those familiar with it, this notation can be both concise and beautiful. But it was developed in an era of parchment and pen, without any inkling of keyboards and the strictly linear sequence of characters so widely used in written communication. Most mainstream computer languages are based on keyboard input.

2. Traditional mathematical notation was developed for communicating between *people* and, like everyday language, has gaps and ambiguities that get sorted out (not always correctly) by human common sense. Computer languages, on the other hand, need to be precise, unambiguous, and interpreted by machines.

We'll attempt to use mathematical notation in a way that limits the conflict between tradition and computer notation. This conflict is particularly acute when it comes to the idea of an "equation," so widely used in high-school mathematics but not a component of mainstream computer languages.


## Functions, inputs, parameters

Our style of notation will be to give functions and their inputs *explicit names*. The basic principle is that a function name is a sequence of letters followed by an empty pair of parentheses, for instance $\sin()$ or $\ln()$. The parentheses provide a clear indication that this is a function name.

::: {.column-margin}
When we come to introduce computer notation in Section @sec-makefun, you'll see that function definition is done in a somewhat different manner. Why? We need to work within the syntax and grammar of the computer language. We will be using the R language, but other mainstream computer languages would impose similar requirements.
:::

As you saw in Chapter @sec-quantity-function-space, our notation for ***defining*** a function includes the names of the parameters. In our mathematical notation, both the name of the function and the names of the inputs are shown on the left-hand side of the $\equiv$ symbol. 
For instance, $$g(u, z) \equiv u\,\cos(z)$$ involves a function named $g()$ and two inputs named $u$ and $z$ respectively. We'll also use names with subscripts and superscripts, e.g. the function names $g_3()$ or $h_\text{water}()$.

A sensible person will define a function because they are planning to use it later on, perhaps multiple times. "Using" a function might mean including it in the formula in the definition of another function. But there is also a more specific sense of "using" to which we need to give a precise name. To ***apply a function*** means providing specific input quantities so that the output of the function can be calculated. An equivalent phrase is ***evaluate a function on*** an input(s). For instance, to apply the function $g()$ to the input quantity 3, any of the following mathematical expressions might be used:
$$g(3)\ \ \ \text{or}\ \ \ \ g(x=3) \ \ \ \text{or}\ \ \ \ g(x)\left.\Large\strut\right|_{x=3}\ .$$
Remember that $g(3)$ or its equivalents are not themselves functions. They are the quantity that results from applying a the function to an input quantity.

::: {.column-margin}
Distinguish carefully between the ***definition*** of a function, say, $g(t) \equiv \sin(t)/t$ and the ***application of a function to an input***. When a function is being applied, the argument can be a numeral or any name that contains the value to serve as input. For instance, any of $g(b)$, $g(\text{age})$, or $g(\text{population})$ can be correct ways to apply $g()$.
:::

The right-hand side of a function definition is a ***formula***. The formula specifies how each of the inputs will get used in a computation of the function output. When a function has more than one input, the input names serve to indicate where each input goes in the formula defining the calculation.  For instance:
$$h(x, y) \equiv x^2 e^y\ .$$
$h()$ is a completely different function than, say,
$f(x, y) \equiv y^2 e^x$. 


### Input names

::: {.column-margin}
You may notice that we use the function names $f()$, $g()$, and $h()$ a lot. Consider these names to be the equivalent of pronouns in English like "this", "that", "it", and so on. Function names like $f()$ or $F()$  or $G()$ will be used when we need to refer to a function for just a moment: a sentence, a paragraph, a section.
:::

To simplify identifying function definitions, we tend to use a small set of names for inputs:


- $\large x$ or $\large y$ or $\large z$. 
- $\large t$. This name is typically used when the input is meant to be ***time***. 
- Less frequently, $u$, $v$, $w$ when the other arguments are already in use.

In modeling, to make clearer the relationship of functions and the real-world setting, it's a good idea to use more descriptive names, like $T$ for "temperature" or $V$ for volume, or even $\text{altitude}$ (which describes itself). 

::: {.column-margin}
In everyday speech, an "argument" is a discussion between people with differing views. But in mathematics and computing, ***argument*** means something else entirely: it is a synonym for "input to a function."
:::

Often, the functions we define will have formulas that include quantities other than the inputs. For instance, we might define:
$$h(t) \equiv A \sin(t) + B\ .$$
This definition explicitly identifies $t$ and the name of the function input. So what are $A$ and $B$? These names also stand for quantities, and to apply the function---say, $h(t=3)$---we would have to know the values of these quantities. We use the word ***parameter*** to refer to such quantities.

Distinguishing between *inputs* and *parameters* is an important way to communicate with the human reader. The idea is that a function, once defined, will be applied to inputs potentially many times. What changes between these function applications is the value of the input quantity. By writing a quantity as a parameter, we are signaling that these quantities will not be changing when we apply the function.

::: {.column-margin}
There is no absolute rule for identifying a named quantity used in a function's formula as a parameter rather than as an input. It's a matter of style and the conventions of the field in which you're working. When we get to the computer notation for defining functions, you'll see that we simplify things by considering all named quantities used in a function formula as inputs.
:::

::: {.example}
A pendulum is a device that swings back and forth from a fixed pivot. The **period** of a pendulum is the time it takes to go through one complete cycle of motion---one "back" and one "forth." It happens that it is simple to compute the period of a pendulum, $$\text{period}(L) \equiv \sqrt{\strut L/g\ }\ ,$$ where $L$ is the length of the pendulum, $g$ is the "acceleration due to gravity." 

We could have written the function as $\text{period}(L, g) \equiv \sqrt{\strut L/g\ }$, treating both quantities $L$ and $g$ as inputs. We wrote instead $\text{period}(L)$ to signify something to the human reader: that we are anticipating the user of $\text{period}()$ to be calculating the periods of various pendula, with different $L$, but all in about the same location. That location will presumably be near the surface of the Earth, where $g \approx 9.8$ m/s^2^. In other words, the definition of $\text{period}(L)$ treats the acceleration due to gravity as a *parameter* rather than an input.

Of course, you might be the kind of person who puts pendula in elevators or on Mars. If so, you would need to use a different value for $g$ than $9.8$ m/s^2^.

You'll see much more use of parameters in Block @sec-modeling-part when we use parameters to "fit" functions to data.
:::

### Parameter names

To make it easy to recognize ***parameters***, we'll use names like $a$, $b$, $c$, $\ldots$, or their upper-case cousins $A$, $B$, $\ldots$. For instance, here is a definition of a function called a "cubic polynomial": 
$$h(x)\equiv a + b x + c x^2 + d x^3\ .$$

::: {.column-margin}
Pronounce names $a_0$ or $b_3$ as "a-sub-zero" and "b-sub-three" respectively.
:::

But there will be occasions where we need to compare two or more functions and run out of appropriate names from the start of the alphabet. A way to keep things organized is to use subscripts on the letters, for instance comparing
$$g(x) \equiv a_0 + a_1 x^2 + a_2 x^2 + a_3 x^3 + a_4 x^4$$
to 
$$f(x) \equiv b_0 + b_1 x^2 + b_2 x^2\ .$$

::: {.column-margin}
The tradition of using letters from the start of the alphabet as parameter names comes from Isaac Newton.

Professional models often use Greek letters as parameter names: $\alpha$, $\beta$, $\gamma$, $\delta$, ...
:::

### Functions without names

Traditional mathematical notation writes many functions both without a name and without the parentheses. Examples that you have likely seen are $x^2$, $\sqrt{\strut x}$, and $e^x$. If we were to absolutely impose the name/parentheses principle we would refer to these functions as, say, square() and sqrt() and exp(). Notice that the $x$ is not part of the name.

Sometimes will will use names like square() just to emphasize the point that we are talking about a function. But for the most part we will stick to the traditional form because it is ubiquitous and recognizable by most readers. 

The name/parentheses notation, like exp() or sin() allows us to avoid having to write $x$ as the indicator of where the input to the function goes. That's helpful because, after all, the actual input might be something completely different from $x$.

## Special inputs

We'll create functions as models of a real-world situation. Once created, we generally have to extract information from the function that informs the real-world choice or decision or understanding that we need to make or develop.

There are many forms that the extracted information will take, depending on circumstance. With surprising frequency, two types of information turn out to be useful:

- The set of inputs that produces a maximum or minimum output.
- Inputs that produce a specific output.

We'll call these ***special inputs*** and will study the techniques for determining them later in the book. For now, though, focus on the notation will will use so that you can spot when a special input is being used. 

As we've stated before, the names of inputs will tend to be letters from the back of the alphabet: $t$, $u$, $v$, $x$, $y$, $z$. Each such name refers to the entire set of possible inputs to a function. When we want to refer to a specific input that describes a particular feature of a function, we will use the standard input names with a superscript---for instance, $x^\star$---or a subscript like $y_1$ or $u_0$.

## Computing: commands and evaluation

Mathematical notation evolved for the purpose of communication among people. With the introduction of programmable computers in the middle of the 20th century, a notation was needed to communicate between people and hardware. It turns out that traditional mathematical notation in calculus is not fully adequate for this purpose. 

Computers need to distinguish between ***declarative*** and ***imperative*** statements. A declarative statement, like $g(z) \equiv z \cos(z)$ defines and describes a relationship. An imperative statement is a direction to **do some action**. For instance, "The store is on the next block," is declarative. "Bring some crackers from the store," is imperative. 


The names and format of such  instructions---e.g. make a mathematical function from a formula, draw a graph of a function, plot data---are given in the same function notation we use in math. For example, `makeFun()` constructs a function from a formula, `slice_plot()` graphs a function, `gf_point()` makes one style of data graphic. These R entities saying "do this" are also called "functions." 

When referring to such R "do this" functions, we'll refer to the stuff that goes in between the parentheses as "arguments." The word "input" would also be fine. The point of using "input" for math functions and "argument" for R "do-this" functions is merely to help you identify when we are talking about mathematics and when we are talking about computing.


With computers, writing an expression in computer notation goes hand-in-hand with ***evaluating*** the notation. We'll start with the simplest mode of evaluation, where you are writing the expression in the ***console*** for the language. @fig-R-console shows and example the console tab provided by the RStudio application. 

```{r echo=FALSE}
#| label: fig-r-console
#| fig-cap: "An RStudio console tab for writing expressions and evaluating them. The `>` is the ***prompt*** after which you write your expression, here shown in $\\color{blue}{\\text{blue}}$. Pressing the \"return\" key causes the language interpreter to evaluate the command."
#| fig-cap-location: margin
knitr::include_graphics("www/console.png")
```

In @fig-r-console we have come in to the story in the middle of the action. To start, there was just a prompt character.

$\color{blue}{\mathtt >}$

The person at the keyboard then typed a simple expression: `2 + 3`

$\color{blue}{\mathtt >\  2 + 3}$

Having completed the expression, the keyboarder presses "return." The RStudio application sends the expression to the software that "interprets" it according to the rules of the R language. `2 + 3` is a complete, valid R expression, an imperative statement. Consequently, the R-language software carries out the action specified---adding 2 and 3---and returns the result to RStudio, which displays it just below the expression itself. 

$\color{blue}{\mathtt >\  2 + 3}\\\mathtt{[1]\ 5}$

Note that the value of the expression is simply the number `5`. The R language is set up to **format** numbers with an index, which is helpful when the value of the expressions is a large set of numbers. In the case here, with just a single number in the result of evaluating the expression, the index is simply stating the obvious. 

Having printed the result of evaluating the `2 + 3` expression, RStudio shows another prompt, signally that it's ready for you to enter your next expression. In @fig-r-console we're seeing the console after the person at the keyboard has responded to the prompt by writing another expression, pressed return, had RStudio print the value of that expression, and displayed a new prompt. 

The two expressions shown in the console in @fig-r-console both evaluate to single numbers. We say, "the command returns a value."  The ***command*** is a valid R expression followed by the signal (pressing the "Return" key) to evaluate the command. The ***value*** of the expression is the result of evaluating the command.

::: {.column-margin}
In a mathematical statement like $h(x) \equiv 3 x + 2$, the $\equiv$ indicates that the statement is declarative. On the other hand, applying a function to a value, as in $h(3)$, is an imperative statement. 
:::

Another common form of R expression is ***assignment***, a declarative statement. An assignment gives a name to a value. It's done using a symbolic name and the `<-` token:

```{r}
b <- 3
```

The result of evaluating this command is to store in the computer memory, under the name `b`, Because the value is being stored, R is designed *not* to display the value as happened with the first two commands in the console. If you want to see the value printed out, give the name as an imperative command:

```{r collapse=TRUE}
b
```

Often, declarative and imperative statements are combined, for instance
```{r}
b <- 22/7
```

::: {.column-margin}
This book displays the command being evaluated in a gray box, without a prompt. The value returned by the command is displayed underneath the command, prefaced by $\color{red}{\mathtt{\#\#}}$. In the book formatting, the four commands we have just described would be displayed in this way:

```{r collapse=TRUE}
#| layout-ncol: 2
2 + 3
sqrt(16)
b <- 3
b <- 22/7
b
```

When reading this book, take care to distinguish between the display of a command and the display of the value returned by that command. The first is something you type, the second is printed by the computer.
:::

## Functions in R/mosaic {#sec-makefun}

One of the fundamental mathematical operations in this book is ***defining functions***. You've already seen the way we use mathematical notation to define a function, for instance, 
$$h(t) \equiv 1.5\, t^2 - 2\ .$$
The R/mosaic equivalent to the definition of $h()$ is:

```{r}
h <- makeFun(1.5*t^2 - 2 ~ t)
```

Once you have defined a function, you can evaluate it on an input. The R notation for evaluating functions is exactly the same as with mathematical notation, for instance,

```{r}
h(4)
```

or 

```{r}
h(t=4)
```

There are obvious differences, however, between the mathematical and computing notation used to define a function. All the same information is being provided, but the format is different. That information is:

1. the name of the function: $h()$ or `h`. When writing the name of a computer-defined function, we'll put the reminder parentheses after the name, as in `h()`. 
2. the name of the input to the function: $x$ or `x`
3. the calculation that the function performs, written in terms of the input name. $1.5 t^2 -2$ or `1.5 * t^2 - 2`.

Laying out the two notation forms side by side let's us label the elements they share:

```{r echo=FALSE}
knitr::include_graphics("www/formula-rosetta.png")
```

For the human reading the mathematical notation, you know that the statement defines a function because you have been told so. Likewise, the computer needs to be told what to do with the provided information. That's the point of `makeFun()`. There are other R/mosaic commands that could take the same information and do something else with it, for example create a graph of the function or (for those who have had some calculus) create the derivative or the anti-derivative of the function.

::: {.takenote data-latex=""}
In R, things like `makeFun()` are called "functions" because, like mathematical functions, they turn inputs into outputs. In the case of `makeFun()`, the input is a form called a ***tilde expression***, owing to the character tilde (<span style="font-size:250%'">~</span>) in the middle. On the right-hand side of the tilde goes the name of the input. On the left-hand side is the R expression for the formula to be used, written as always in terms of the input name. The whole tilde expression is taken as the one argument to `makeFun()`. Although it may seem odd to have punctuation in the middle of an argument, remember that something similar happens when we write $h(t=3)$.
:::

## Names and assignment

The command

```{r}
h <- makeFun(1.5*t^2 - 2 ~ t)
``` 

gives the name `h` to the function created by `makeFun()`. Good choice of names makes your commands much easier for the human reader. 

The R language puts some restrictions on the names that are allowed. Keep these in mind as you create R names in your future work:

1. A name is the **only**^[Note for R experts: Strictly speaking, the thing to the left of `<-` must be an "assignable," which includes names with indices (e.g. `Engines$hp` or `Engines$hp[3:5]`
and other forms). We will not use indexing in *MOSAIC Calculus*; we won't need it.] thing allowed on the left side of the assignment symbol `<-`. 
2. A name must *begin* with a letter of the alphabet, e.g. `able`, `Baker`, and so on.
3. Numerals can be used after the initial letter, as in `final4` or `g20`. You can also use the period `.` and underscore `_` as in `third_place`. No other characters can be used in names: no minus sign, no `@` sign, no `/` or `+`, no quotation marks, and so on. 

For instance, while `third_place` is a perfectly legitimate name in R, the following are not: `3rd_place`, `third-place`. But it's OK to have names like `place_3rd` or `place3`, etc., which start with a letter.

R also distinguishes between letter case. For example, `Henry` is a different name than `henry`, even though they look the same to a human reader.




## Formulas in R

The constraint of the keyboard means that computer formulas are written in a slightly different way than the traditional mathematical notation. This is most evident when writing multiplication and exponentiation. Multiplication must *always* be indicated with the `*` symbol, for instance $3 \pi$ is written `3*pi`. For exponentiation, instead of using superscripts like $2^3$ you use the "caret" character, as in `2^3`. The best way to learn to implement mathematical formulas in a computer language is to read examples and practice writing them. 

Here are some examples:

Traditional notation | R notation 
---------------------|-------------
$3 + 2$              | `3 + 2`
$3 \div 2$           | `3 / 2`
$6 \times 4$         | `6 * 4`
$\sqrt{\strut4}$     | `sqrt(4)`
$\ln 5$              | `log(5)`
$2 \pi$              | `2 * pi`
$\frac{1}{2} 17$     | `(1 / 2) * 17`
$17 - 5 \div 2$      | `17 - 5 / 2`
$\frac{17 - 5}{\strut 2}$   | `(17 - 5) / 2`
$3^2$                | `3^2`
$e^{-2}$             | `exp(-2)`


Each of these examples has been written using numbers as inputs to the mathematical operations. The syntax will be exactly the same when using an input name such as `x` or `y` or `altitude`, for instance `(x - y) / 2`. In order for that command using `x` and `y` to work, some meaning must have been previously attached to the symbols. We'll come back to this important topic on another day.


## Exercises

`r if (knitr::is_latex_output()) knitr::knit_exit()`

`r Znotes::insert_calcZ_exercise(2.1, "TKWEW", "Exercises/convention-drill.Rmd")`

`r Znotes::insert_calcZ_exercise(2.2, "LDNE", "Exercises/function-notation.Rmd")`

`r Znotes::insert_calcZ_exercise("2.3", "kZG5Fj", "Exercises/puppy-build-radio.Rmd")`

`r Znotes::insert_calcZ_exercise("2.4", "aeOnO5", "Exercises/horse-sing-drawer.Rmd")`

`r Znotes::insert_calcZ_exercise("2.5", "ooJK5d", "Exercises/pine-light-mug.Rmd")`

<!-- basic R instructions -->
`r Znotes::insert_calcZ_exercise("2.6", "BXCA4", "Exercises/fish-sees-tree.Rmd")`

`r Znotes::insert_calcZ_exercise("2.7", "0V510o", "Exercises/goat-look-boat.Rmd", skill="R formula notation")`

`r Znotes::insert_calcZ_exercise("2.8", "Ce79t3", "Exercises/pollen-fly-lamp.Rmd", skill="makeFun()")`

<!-- when things go wrong -->
`r Znotes::insert_calcZ_exercise("2.9", "BaEJkS", "Exercises/seahorse-take-pen.Rmd")`

## Drill questions

`r Znotes:::MC_counter$reset(labels="roman")`

```{r drill-M01-1, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Which of these is the symbol for "is defined as"? )",
r"($=$)" = r"(An equals sign says that the two sides happen to be equal, not that the left side is **defined** as the right side.)",
  r"(+$\equiv$+)" = r"(Three parallel bars signify a definition.)",
  r"($\sim$)" = r"( )",
  r"($\approx$)" = r"( )",
  random_answer_order=TRUE
)
```

```{r drill-M01-2, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What is the name of the function defined by $$f(y) \equiv \sin(y) + e^y \ ?$$ )",
r"(+$f$+)" = r"(Note that we will usually write function names with trailing parentheses, like $f()$, in order to remind you that $f$ refers to a function rather than an input or parameter or whatever.)",
  r"($\sin$)" = r"( )",
  r"($f(y)$)" = r"(This isn't a function name. This is how we write the **output** from applying function $f()$ to the input denoted by the name $y$.)",
  random_answer_order=TRUE
)
```

```{r drill-M01-3, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(How do we refer to the output generated by applying $g(x) \equiv x+3$ to the input 3?  )",
r"($g(x)$)" = r"( )",
  r"(+$g(3)$+)" = r"( )",
  r"($y = 6$)" = r"(It's a habit from high-school math to use the name $y$ for outputs. Breaking that habit will help you learn and use calculus.)",
  random_answer_order=TRUE
)
```


```{r drill-M02-1, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Is `xx` a legitimate name in R? )",
r"(+True+)" = r"( )",
  r"(False)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M02-2, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Is `x_x` a legitimate name in R? )",
r"(+True+)" = r"( )",
  r"(False)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M02-3, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Is `-x` a legitimate name in R? )",
r"(True)" = r"( )",
  r"(+False+)" = r"(The minus sign are other such symbols are not allowed characters in an R name.)",
  random_answer_order=FALSE
)
```



```{r drill-M02-4, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Is `3x` a legitimate name in R? )",
r"(True)" = r"( )",
  r"(+False+)" = r"(Names should start with a letter)",
  random_answer_order=FALSE
)
```



```{r drill-M02-5, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Is `x3` a legitimate name in R? )",
r"(+True+)" = r"(Numbers are OK in names, so long as the first character is a letter)",
  r"(False)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M02-6, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Is `sqrt` a legitimate name in R? )",
r"(+True+)" = r"(In fact, it is the name of an oft-used function in R.)",
  r"(False)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M02-7, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Is `x + y` a legitimate name in R? )",
r"(True)" = r"( )",
  r"(+False+)" = r"(`x + y` is an R expression that uses names, but the expression is not itself a name.)",
  random_answer_order=FALSE
)
```



```{r drill-M02-8, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Is `3 * x` a legitimate name in R? )",
r"(True)" = r"( )",
  r"(+False+)" = r"(`*` and <space> are not acceptable characters in a name.)",
  random_answer_order=FALSE
)
```



```{r drill-M02-9, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Is `xprime` a legitimate name in R? )",
r"(+True+)" = r"( )",
  r"(False)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M02-10, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Is `x prime` a legitimate name in R? )",
r"(True)" = r"( )",
  r"(+False+)" = r"(Names cannot have blank spaces internally.)",
  random_answer_order=FALSE
)
```



```{r drill-M02-11, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Is `dx` a legitimate name in R? )",
r"(+True+)" = r"( )",
  r"(False)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M02-12, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Is `xx` a legitimate name in R? )",
r"(+True+)" = r"( )",
  r"(False)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M02-13, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Is `dx_f` a legitimate name in R? )",
r"(+True+)" = r"( )",
  r"(False)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M02-14, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What's wrong with this assignment statement?<br> `x < 4` )",
r"(Nothing)" = r"( )",
  r"(+It's missing part of the `<-` token.+)" = r"( )",
  r"( `x` is an improper name.)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M02-15, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What's wrong with this assignment statement?<br> `3*x <- 4` )",
r"(Nothing)" = r"(The item to the left of `<-` needs to be a valid name. `3*x` is not.)",
  r"(It should use addition instead of multiplication.)" = r"( )",
  r"(+The item to the left of `<-` needs to be a name+)" = r"(`3 * x` is an instruction to multiply 3 times x. It is not a name.)",
  r"(There's no `x` on the right-hand side of the assignment arrow.)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M02-16, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What's wrong with this assignment statement?<br> `x -> 3+4` )",
r"(Nothing)" = r"( )",
  r"(You can't use addition in an assignment statement.)" = r"(You can, but it has to be on the right side of the assignment, where you construct the value to be assigned to the name on the left side.)",
  r"(+The assignment has to point toward the **name**, not the *value*+)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M02-17, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(We can write something like <br>$f(x) \equiv x^2$ </br> in mathematical notation. Is it legit in R to write `f(x) <- x^2` ? )",
r"(Yes, it's fine.)" = r"( )",
  r"(+`f(x)` is not a valid name in R.+)" = r"( )",
  r"(Almost. You need to use \(\equiv\) instead of `<-` .)" = r"(There's no symbol \(\equiv\) on the keyboard or recognized in the R language.)",
  random_answer_order=FALSE
)
```




```{r drill-M03-22, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Using our notation conventions from the textbook, which one of the following kinds of things is $y_0 ?$ )",
r"(+A constant+)" = r"( )",
  r"(A function name)" = r"( )",
  r"(An input name)" = r"(A subscript (like $_0$ here) or non-numeric superscript (like $^\star$) on what would otherwise be an input name will be instead a **constant**.)",
  random_answer_order=FALSE
)
```


```{r drill-M04-1, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Using our notation conventions from the textbook, which one of the following kinds of things is $t^\star?$ )",
r"(+A constant+)" = r"( )",
  r"(A function name)" = r"( )",
  r"(An input name)" = r"(A subscript (like $_0$ here) or non-numeric superscript (like $^\star$) on what would otherwise be an input name will be instead a **constant**.)",
  random_answer_order=FALSE
)
```


```{r drill-M04-2, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Using our notation conventions from the textbook, which one of the following kinds of things is $B ?$ )",
r"(+A constant+)" = r"( )",
  r"(A function name)" = r"( )",
  r"(An input name)" = r"(The letters from the start of the alphabet, a-d, or A-D will refer to a **constant**. )",
  random_answer_order=FALSE
)
```


```{r drill-M04-3, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Using our notation conventions from the textbook, which one of the following kinds of things is $F() ?$ )",
r"(A constant)" = r"( )",
  r"(+A function name+)" = r"(Our standard pronouns for functions are $f(), g(), h()$ and $F(), G(), H()$)",
  r"(An input name)" = r"( )",
  random_answer_order=FALSE
)
```


```{r drill-M04-4, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Using our notation conventions from the textbook, which one of the following kinds of things is $u ?$ )",
r"(A constant)" = r"( )",
  r"(A function name)" = r"( )",
  r"(+An input name+)" = r"(Letters from the end of the alphabet, $u, v, w, x, y, z$, generally refer to an input to a function. But, remember, something like $x_0$ will always be a constant.)",
  random_answer_order=FALSE
)
```


```{r drill-M04-5, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Can function names be multiple letters, e.g. `g3()` or `altitude()`? )",
r"(+Yes+)" = r"(And they often do. Almost all R functions have multi-letter names, like `exp()`, `sin()`, `dnorm()`, and such. When you are building a model, it's helpful to use *mnemonic* function names rather than the usual pronouns like $f(), g()$, an $h()$. We use the short pronouns throughout the book whenever we are discussing general mathematical properties rather than specific models.)",
  r"(No)" = r"( )",
  random_answer_order=FALSE
)
```

```{r drill-M04-7, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(In the book, will input names have subscripts, like $x_0$ or  $u_2 ?$ )",
r"(Yes)" = r"( )",
  r"(+No+)" = r"(In the textbook, we try to reserve names like $x_0$ or $u_2$ for **constants**. But mathematics usage generally doesn't always adopt this helpful convention.)",
  random_answer_order=FALSE
)
```


```{r drill-M04-8, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(In the book, what is meant by the word "**variable**"? )",
r"(It's the same as input.)" = r"(Use **input** rather than variable! Even if you're used to calling quantities like $x$ and $y$ variables, it's a confusing practice since it can mean so many different things. In calculus, in this course, we'll try to be strict about using the words **input** and **output**)",
  r"(It's the same as output.)" = r"( )",
  r"(+A column in a data table.+)" = r"(This is the use in statistics and data science. In calculus, we'll try to avoid confusing by using **input** and **output** instead.)",
  random_answer_order=TRUE
)
```



```{r drill-M08-8, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What is the name of the **function** being defined in $a(b) \equiv 3 x + 2 b$? )",
r"(+a+)" = r"(Any name $ggg$ appearing in a definition of the form $ggg(xxx) \equiv \text{some_function_of}(xxx)$} is being explicitly declared as the name of the function. Names don't have to be $f()$, $g()$, or $h()$, even though those are the pronouns we use most often.)",
  r"(b)" = r"( )",
  r"(x)" = r"( )",
  random_answer_order=FALSE
)
```




```{r drill-M08-9, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What is the name of the **input** to the function being defined in $a(b) \equiv 3 x + 2 b$? )",
r"(a)" = r"( )",
  r"(+b+)" = r"(Any name $yyy$ appearing in a definition of the form $xxx(yyy) \equiv \text{some_function_of}(yyy)$} is being explicitly declared as the name of the the argument. Names don't have to be $x, y, z, t, u, v, w$, even though those are the the names we use most often.)",
  r"(x)" = r"( )",
  random_answer_order=FALSE
)
```

```{r drill-M08-10, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What is wrong with this function definition?  $$\text{dorothy(kansas)} \equiv \text{niece_of(Auntie_Em)} \times \text{kansas}$$ )",
r"(You can't name a function "dorothy.")" = r"(Why not?)",
  r"("kansas" is a US state, not the name of an argument.)" = r"( )",
  r"("dorothy" and "kansas" should be capitalized.)" = r"(That's true in English, but we're writing mathematics here and we get to make the choices.)",
  r"(Auntie Em is a person, not a number.)" = r"(There's no reason why a person can't be the argument to a function. For instance, we might have blood_pressure(patient3252).)",
  r"(+Nothing.+)" = r"( )",
  random_answer_order=FALSE
)
```

```{r drill-M08-11, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What's wrong with this function definition? $$\text{electric}(z) \equiv 3 z + \ln()$$ )",
r"(+No input has been given to $\ln()$.+)" = r"(Although $\ln()$ is an important function, on the right-hand side of the definition, it can only make sense if it is evaluated on some argument. So writing $\ln(z)$ or even $\ln(year)$ would have made this a proper function definition.)",
  r"('electric() ' should have been written as E().)" = r"(The letter E can be a fine function name, but so can 'electric.')",
  r"(Nothing)" = r"( )",
  random_answer_order=FALSE
)
```

```{r drill-Quiz-1-27, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(You are modeling the population of *E. coli* growing in optimal conditions. (Optimal for the *E. coli*, not for you!)  In R, you've written <br>`population <- makeFun(100*exp(hours) ~ hours)`<br>What's the correct definition in traditional notation? )",
r"($\text{population} \equiv 100 e^\text{hours}$)" = r"( )",
  r"($\text{population}(t) \equiv 100 e^\text{hours}$)" = r"(The argument should be called hours, not t.)",
  r"(+$\text{population}(\text{hours}) \equiv 100 e^\text{hours}$+)" = r"( )",
  r"(None of the above.)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-Quiz-1-26, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(In traditional notation, $$\text{Celsius}(\text{Fahrenheit}) \equiv \frac{5}{9} (\text{Fahrenheit} - 32)$$ defines a function named `Celsius()`. This of the following correctly defines that function in R? )",
r"(`Celsius(Fahrenheit) <- makeFun(5*(Fahrenheit-32)/9)`)" = r"(The left side of the assignment operator `<-` should be simply the name of the function, in this case `Celsius`.)",
  r"(`Celsius <- makeFun(5/9*Fahrenheit - 32 ~ Fahrenheit)`)" = r"( )",
  r"(`Celsius() <- makeFun(5*(Fahrenheit-32)/9 ~ Fahrenheit)`)" = r"(The `()` in `Celsius()` are not allowed in an R name.)",
  r"(+`Celsius <- makeFun(5*(Fahrenheit-32)/9 ~ Fahrenheit)`+)" = r"( )",
  r"(`Celsius(Fahrenheit) <- makeFun(5*(Fahrenheit-32)/9 ~ Fahrenheit)`)" = r"(Everything is good, but the name on the left side of the assignment operator `<-` should be simply `Celsius`)",
  random_answer_order=TRUE
)
```




```{r drill-Quiz-1-25, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Which of these is the right way to translate $e^x$ into R? )",
r"(`e^x`)" = r"(This is a bit of arithmetic, raising the value of whatever is stored in the object `e` to the power `x`. )",
  r"(+`exp(x)`+)" = r"( )",
  r"(`e(x)`)" = r"(There's no function named `e()`.)",
  r"(There is no R equivalent.)" = r"(Yes there is. Remember $e^x$ has a definite meaning in traditional notation.)",
  random_answer_order=FALSE
)
```



```{r drill-Quiz-1-24, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(If `x` has been assigned the value `pi/2`, what will be the value of the R expression `2 sin(x)`? )",
r"(0, since $\sin(\pi/2) = 0$.)" = r"(Actually, $\sin(\pi/2) = 1$, but that's not the only problem with this answer.)",
  r"(1, since $\sin(\pi/2) = 1$.)" = r"(What about the `2`?)",
  r"(2, since $\sin(\pi/2) = 1$.)" = r"(This would be right if the R expression had been written correctly.)",
  r"(+No value. The expression is in error.+)" = r"(It should presumably be `2*sin(x)`.)",
  random_answer_order=FALSE
)
```



```{r drill-Quiz-1-18, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What's wrong with this R command for defining a function?<br>`f <- 3*x + 2` )",
r"(It needs to be `f(x) <- 3*x + 2`)" = r"(That's reminiscent of traditional notation but to create a function we use `f <- makeFun( ... )`)",
  r"(It needs to be `f <- makeFun(3*x + 2)`)" = r"(Almost, but you're missing the right-hand side of the tilde expression, `3*x ~ x`, which tells us that `x` will be the name of the argument to `f()`.)",
  r"(+It needs to be `f <- makeFun(3*x + 2 ~ x)`.+)" = r"( )",
  r"(Nothing is wrong)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-Quiz-1-19, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What's wrong with this R command for creating an exponential function named `g`?<br> `g <- makeFun(e^y ~ y)` )",
r"(+`e^y` is not the exponential function+)" = r"(It should be `exp(y)`)",
  r"(It uses `y` as the argument instead of `x`.)" = r"(You can use any name you like for the argument, so long as you use it consistently.)",
  r"(Better to name the argument `x`)" = r"(`x` and `y` (and many others) are excellent names for arguments.)",
  r"(Nothing)" = r"( )",
  random_answer_order=TRUE
)
```



```{r drill-Quiz-1-20, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What's suspect about this R command?<br> `g <- makeFun(exp(y) ~ x)` )",
r"(+The formula is `exp(y)` but the argument name is `x`+)" = r"( )",
  r"(There's a tilde expression as the argument to `makeFun()`.)" = r"(That's exactly what is supposed to happen: give a tilde expression as the input to `makeFun()` !)",
  r"(The function name should be `G`, not `g`.)" = r"(The function name is your choice! Either would be right.)",
  r"(Nothing)" = r"(I guess that "suspect" is in the eye of the beholder. But I think there's a better choice here.)",
  random_answer_order=FALSE
)
```



```{r drill-Quiz-1-21, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What's wrong with the R expression `sin*(x + 3)`? )",
r"(+There is no function named `sin*()`+)" = r"(And besides, `*` cannot be part of any valid name in R.)",
  r"(It should be `sin+(x+3)`)" = r"(There's no function named `sin+()`)",
  r"(It should be `sin^(x+3)`)" = r"(There is no function named `sin^()`)",
  r"(Nothing)" = r"(Hint: What's the name of the function being used? Is that really a function?)",
  random_answer_order=FALSE
)
```



```{r drill-Quiz-1-22, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What does `e^3` mean in R? )",
r"(It corresponds to $e^3$, which happens to be 20.09)" = r"(Remember that $e^x$ is the traditional notation for the exponential function. In R, the exponential function is written `exp()`.)",
  r"(A shorthand for `eee`.)" = r"(There is no shorthand for names in R.)",
  r"(+The value stored under the name `e` will be raised to the third power.+)" = r"(And if there is no object named `e`, you'll get an error message.)",
  random_answer_order=FALSE
)
```



```{r drill-Quiz-1-23, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What's missing in the R expression `(x+3)(x+1)`? )",
r"(There's a missing closing parenthesis.)" = r"( )",
  r"(There's an extra closing parenthesis.)" = r"( )",
  r"(+The multiplication symbol, `*`, is missing.+)" = r"(It should be `(x + 3)*(x+1)`.)",
  r"(Nothing)" = r"( )",
  random_answer_order=TRUE
)
```



```{r drill-M04-14, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Which of these phrases is most appropriate for describing what the R command `z <- sin(17)` is doing?  )",
r"(Gives a name to a value.)" = r"( )",
  r"(+Applies a function to an input to produce an output.+)" = r"( )",
  r"(Makes a copy of an existing object.)" = r"( )",
  r"(The name of an object.)" = r"( )",
  r"(It's invalid as a command.)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M04-15, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Which of these phrases is most appropriate for describing what the R command `sin(17)` is doing?  )",
r"(Gives a name to a value.)" = r"( )",
  r"(+Applies a function to an input to produce an output.+)" = r"( )",
  r"(Makes a copy of an existing object.)" = r"( )",
  r"(The name of an object.)" = r"( )",
  r"(It's invalid as a command.)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M04-16, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Which of these phrases is most appropriate for describing what the R command `z <- x` is doing?  )",
r"(Gives a name to a value.)" = r"( )",
  r"(Applies a function to an input to produce an output.)" = r"( )",
  r"(+Makes a copy of an existing object.+)" = r"( )",
  r"(The name of an object.)" = r"( )",
  r"(It's invalid as a command.)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M04-17, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Which of these phrases is most appropriate for describing what the R command `fred` is doing?  )",
r"(Gives a name to a value.)" = r"( )",
  r"(Applies a function to an input to produce an output.)" = r"( )",
  r"(Makes a copy of an existing object.)" = r"( )",
  r"(+The name of an object.+)" = r"(When you give the name of an object as a stand-alone command, R prints out the value of that object.)",
  r"(It's invalid as a command.)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M04-18, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(In the statement `pnorm(3, mean=4, sd=6 )`, what is `pnorm`?  )",
r"(+The name of the function being applied to the three arguments.+)" = r"( )",
  r"(A named argument)" = r"( )",
  r"(An argument to be used without a name.)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M04-19, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(In the statement `pnorm(3, mean=4, sd=6 )`, what is `mean=4`?  )",
r"(The name of the function being applied to the three arguments.)" = r"( )",
  r"(+A named argument+)" = r"( )",
  r"(An argument to be used without a name.)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M04-20, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(In the statement `pnorm(3, mean=4, sd=6 )`, what is `3`?  )",
r"(The name of the function being applied to the three arguments.)" = r"( )",
  r"(A named argument)" = r"( )",
  r"(+An argument to be used without a name.+)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M04-21, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Will the statement `pnorm(x=3, mean=4, sd=6)` give the same result as `pnorm(3, mean=4, sd=6)` ?  )",
r"(Yes, same arguments to the same function means the output will be the same.)" = r"(In general, this is good reasoning. )",
  r"(+No. The name of the first argument to `pnorm()` is not `x`.+)" = r"(You can't always know what are the names of the arguments to the basic built-in functions. So use them without naming the argument.)",
  random_answer_order=FALSE
)
```



```{r drill-M04-22, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Will the statement `pnorm(3, mean=4, sd=6)` give the same result as `pnorm(3, sd=6, mean=4)`?  )",
r"(+Yes.+)" = r"(The names for the arguments tell R how each argument should be used in the function.)",
  r"(No. The arguments are different.)" = r"(When an argument is used with it's name, it can go anywhere in the argument list.)",
  random_answer_order=FALSE
)
```



```{r drill-M04-23, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Will the statement `pnorm(3, mean=4, sd=6)` give the same result as `pnorm(3, sd=4, mean=6)`?  )",
r"(Yes)" = r"(Look carefully at the value given to each argument.)",
  r"(+No+)" = r"(In the first statement, the mean is set to 4, while in the second it's set to 6.)",
  random_answer_order=FALSE
)
```



```{r drill-M04-25, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What is the value of `16^1/2`? )",
r"(4)" = r"(This would be right if the exponent were in grouping parentheses, e.e. `16^(1/2)`. Without those parentheses, the computer reads `16^1/2` as `(16^1) / 2`)",
  r"(+8+)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M04-26, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(What is the value of `16^(1/2)`? )",
r"(+4+)" = r"(Since the `(1/2)` is in grouping parentheses, the expression is asking for 16 to the one-half power, in other words the square root of 16.)",
  r"(8)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M04-27, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Suppose `n <- 3`. What will be the value of `2^n-1`? )",
r"(4)" = r"(Without grouping parentheses around `n-1` the computer interprets `2^n-1` as `(2^n) - 1`)",
  r"(+7+)" = r"( )",
  r"(8)" = r"(What about the `-1` in the expression?)",
  random_answer_order=FALSE
)
```



```{r drill-M04-28, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Suppose `n <- 3`. What will be the value of `2^(n-1)`? )",
r"(+4+)" = r"( )",
  r"(7)" = r"(The grouping parentheses around `(n-1)` mean that the calculation is effectively `2^2`, giving 4.)",
  r"(8)" = r"(What about the `-1` in the expression?)",
  random_answer_order=FALSE
)
```


## Drill Quiz-1

`r Znotes:::MC_counter$reset(labels="roman")`


```{r drill-Quiz-1-1, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Which of these does the symbol $y_0$ suggest using our CalcZ notation conventions? )",
r"(+a constant+)" = r"(We also sometimes refer to a constant as a parameter.)",
  r"(an input to a function)" = r"( )",
  r"(the output from a function)" = r"( )",
  r"(a function name)" = r"( )",
  r"(it's nonsense)" = r"( )",
  random_answer_order=TRUE
)
```



```{r drill-Quiz-1-2, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Given the definition $g(z) \equiv z \sin(z)$, which of these does the symbol $z$ suggest using our CalcZ notation conventions? )",
r"(a constant)" = r"( )",
  r"(+the input to the function+)" = r"( )",
  r"(the output from the function)" = r"( )",
  r"(the function name)" = r"( )",
  r"(it's nonsense)" = r"( )",
  random_answer_order=TRUE
)
```



```{r drill-Quiz-1-3, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Given the definition $g(z) \equiv z \sin(z)$, hich of these does the symbol $g$ suggest using our CalcZ notation conventions? )",
r"(a constant)" = r"( )",
  r"(the input to the function)" = r"( )",
  r"(the output from the function)" = r"( )",
  r"(+the function name+)" = r"(Usually, we write function names with parentheses, like $g()$, just as a reminder that the name refers to a function.)",
  r"(it's nonsense)" = r"( )",
  random_answer_order=TRUE
)
```



```{r drill-Quiz-1-4, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Given the definition $pressure(H) \equiv \exp(- H/10)$, which of these does the symbol $H$ suggest using our CalcZ notation conventions? )",
r"(a constant)" = r"( )",
  r"(+the input to the function+)" = r"(Even though $H$ is not a name we will use frequently for the input to a function, whenever you see $f(H) \equiv ...$, you know that $H$ is being explicitly declared to be a function.)",
  r"(the output from the function)" = r"( )",
  r"(the function name)" = r"( )",
  r"(it's nonsense)" = r"( )",
  random_answer_order=TRUE
)
```



```{r drill-Quiz-1-5, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Given the definition $pressure(H) \equiv exp(-.1 H)$, which of these does the symbol $pressure$ suggest using our CalcZ notation conventions? )",
r"(a constant)" = r"( )",
  r"(the input to the function)" = r"( )",
  r"(the output from the function)" = r"( )",
  r"(+the function name+)" = r"( )",
  r"(it's nonsense)" = r"( )",
  random_answer_order=TRUE
)
```



```{r drill-Quiz-1-6, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(In the definition $h(z) \equiv a z + b$ what is the symbol $z$? )",
r"(a constant)" = r"( )",
  r"(+the input to the function+)" = r"( )",
  r"(the output from the function)" = r"( )",
  r"(the function name)" = r"( )",
  r"(it's nonsense)" = r"( )",
  random_answer_order=TRUE
)
```



```{r drill-Quiz-1-7, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(In the definition $h(z) \equiv a z + b$ what is the symbol $a$? )",
r"(+a constant+)" = r"(We call such constants "parameters" of the function.)",
  r"(the input to the function)" = r"( )",
  r"(the output from the function)" = r"( )",
  r"(the function name)" = r"( )",
  r"(it's nonsense)" = r"( )",
  random_answer_order=TRUE
)
```



```{r drill-Quiz-1-8, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(In `g <- makeFun(3*z + 2 ~ z)`, which is the name of the input to the function `g()`? )",
r"($x$)" = r"( )",
  r"($y$)" = r"( )",
  r"(+$z$+)" = r"( )",
  r"($t$)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M04-9, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Will this statement work in R? <br>`sin(4)` )",
r"(+Yes+)" = r"( )",
  r"(No)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M04-10, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Will this statement work in R? <br>`Sin(4)`</br> )",
r"(Yes)" = r"(It would except for the capital S. R treats capital and lower-case letters as completely different, so the name `abby` is utterly distinct from `Abby` or `aBBy`, etc.)",
  r"(+No+)" = r"( )",
  random_answer_order=FALSE
)
```



```{r drill-M04-11, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Will this statement work in R to calculate $\sin(4)$? <br> `sin[4]` )",
r"(Yes)" = r"(You must always use parentheses, not square braces, to carry the argument to the function.)",
  r"(+No+)" = r"(Only parentheses can be used to hand an argument off to a function.)",
  random_answer_order=FALSE
)
```



```{r drill-M04-6, echo=FALSE, results='markup'}
Znotes::askMC(
  prompt = r"(Can function names have subscripts or superscripts, like $g_0()$ or  $f'() ?$ )",
r"(+Yes+)" = r"(We'll use names like $g_0()$, $g_1()$ in sequence when we're discussing a set of functions that are very closely related, such as refinements.)",
  r"(No)" = r"( )",
  random_answer_order=FALSE
)
```



